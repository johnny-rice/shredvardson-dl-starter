# Lefthook Configuration
# https://lefthook.dev/configuration/
#
# This configuration provides auto-installing git hooks with parallel execution
# for faster validation and better developer experience.

# Commit-msg: Validate commit message format (<1s target)
commit-msg:
  commands:
    commitlint:
      run: |
        echo "üîç Validating commit message..."
        npx --no-install commitlint --edit $1

# Pre-commit: Fast checks for instant feedback (<3s target)
pre-commit:
  parallel: true
  commands:
    # Biome format & lint for instant feedback (<1s)
    biome-check:
      glob: '**/*.{js,ts,jsx,tsx,json}'
      run: |
        echo "‚ö° Running Biome checks..."
        pnpm biome check --write --no-errors-on-unmatched --files-ignore-unknown=true {staged_files}
        # Stage any files that Biome fixed
        git add {staged_files}

    # Markdown linting for instant feedback (<1s)
    markdown-lint:
      glob: '{docs,specs,.claude}/**/*.md'
      run: |
        echo "üìù Linting markdown files..."
        pnpm markdownlint-cli2 --fix {staged_files}
        # Stage any files that markdownlint fixed
        git add {staged_files}

    # Config reference validation for slash commands
    validate-config-refs:
      glob: '.claude/commands/**/*.md'
      run: |
        echo "üîç Validating config references..."
        node scripts/validate-config-refs.js

    # Update micro-lessons index when docs/micro-lessons/ files change
    micro-lessons-index:
      glob: 'docs/micro-lessons/**/*'
      run: |
        echo "üìö Micro-lessons changed, updating index..."
        pnpm learn:index
        if [ -n "$(git diff docs/micro-lessons/INDEX.md)" ]; then
          echo "üìÑ Staging updated INDEX.md"
          git add docs/micro-lessons/INDEX.md
        fi

# Pre-push: Comprehensive validation (target: 8-15s with parallel execution)
pre-push:
  parallel: false # Top-level sequential to control execution order
  commands:
    # Block direct pushes to main branch
    protect-main:
      run: |
        protected_branch='refs/heads/main'
        while read local_ref local_sha remote_ref remote_sha
        do
          if [ "$remote_ref" = "$protected_branch" ]; then
            echo ""
            echo "‚ùå PUSH BLOCKED: Direct pushes to 'main' branch are not allowed!"
            echo ""
            echo "üîÑ To contribute to this repository:"
            echo "   1. Create a feature branch:"
            echo "      git checkout -b feature/your-feature-name"
            echo ""
            echo "   2. Push your feature branch:"
            echo "      git push origin feature/your-feature-name"
            echo ""
            echo "   3. Create a Pull Request on GitHub"
            echo ""
            echo "üí° This workflow ensures proper code review and maintains repository quality."
            echo ""
            exit 1
          fi
        done

    # 1. Check lockfile sync (fast: ~0.5s)
    lockfile-sync:
      run: |
        # Check if origin/main exists before comparing
        if git rev-parse --verify origin/main >/dev/null 2>&1; then
          if git diff --name-only origin/main...HEAD 2>/dev/null | grep -q "package.json"; then
            echo "üì¶ Checking lockfile sync..."
            if ! pnpm install --frozen-lockfile; then
              echo ""
              echo "‚ùå pnpm-lock.yaml is out of sync with package.json"
              echo ""
              echo "üí° Fix: Run 'pnpm install' to update the lockfile"
              echo ""
              echo "üí° To bypass this check (not recommended):"
              echo "   git push --no-verify"
              echo ""
              exit 1
            fi
            echo "‚úÖ Lockfile is in sync"
          fi
        else
          echo "‚ö†Ô∏è Skipping lockfile check (origin/main not found)"
        fi

    # 2 & 3. Run typecheck and lint in parallel (saves ~5-8s)
    parallel-checks:
      run: |
        # Create temp files for collecting output
        TYPECHECK_LOG=$(mktemp)
        LINT_LOG=$(mktemp)

        # Set up cleanup trap that kills background processes
        cleanup() {
          # Kill background processes if still running
          if [ -n "$TYPECHECK_PID" ] && kill -0 "$TYPECHECK_PID" 2>/dev/null; then
            kill "$TYPECHECK_PID" 2>/dev/null || true
          fi
          if [ -n "$LINT_PID" ] && kill -0 "$LINT_PID" 2>/dev/null; then
            kill "$LINT_PID" 2>/dev/null || true
          fi
          # Remove temp files
          rm -f "$TYPECHECK_LOG" "$LINT_LOG"
        }
        trap cleanup EXIT INT TERM

        echo "üîé Type checking..."
        START_TIME_TYPECHECK=$(date +%s)
        pnpm typecheck > "$TYPECHECK_LOG" 2>&1 &
        TYPECHECK_PID=$!

        echo "‚ú® Linting..."
        START_TIME_LINT=$(date +%s)
        pnpm lint > "$LINT_LOG" 2>&1 &
        LINT_PID=$!

        # Wait for both processes with timeout (60 seconds each)
        TIMEOUT=60
        TYPECHECK_EXIT=1
        LINT_EXIT=1

        # Wait for typecheck with timeout
        ELAPSED=0
        while [ $ELAPSED -lt $TIMEOUT ]; do
          if ! kill -0 "$TYPECHECK_PID" 2>/dev/null; then
            wait "$TYPECHECK_PID" 2>/dev/null
            TYPECHECK_EXIT=$?
            break
          fi
          sleep 1
          ELAPSED=$((ELAPSED + 1))
        done

        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "‚ö†Ô∏è  Typecheck timed out after ${TIMEOUT}s"
          kill "$TYPECHECK_PID" 2>/dev/null || true
          wait "$TYPECHECK_PID" 2>/dev/null || true
          TYPECHECK_EXIT=1
        fi

        END_TIME_TYPECHECK=$(date +%s)
        TYPECHECK_DURATION=$((END_TIME_TYPECHECK - START_TIME_TYPECHECK))

        # Wait for lint with timeout
        ELAPSED=0
        while [ $ELAPSED -lt $TIMEOUT ]; do
          if ! kill -0 "$LINT_PID" 2>/dev/null; then
            wait "$LINT_PID" 2>/dev/null
            LINT_EXIT=$?
            break
          fi
          sleep 1
          ELAPSED=$((ELAPSED + 1))
        done

        if [ $ELAPSED -ge $TIMEOUT ]; then
          echo "‚ö†Ô∏è  Lint timed out after ${TIMEOUT}s"
          kill "$LINT_PID" 2>/dev/null || true
          wait "$LINT_PID" 2>/dev/null || true
          LINT_EXIT=1
        fi

        END_TIME_LINT=$(date +%s)
        LINT_DURATION=$((END_TIME_LINT - START_TIME_LINT))

        # Display typecheck output
        cat "$TYPECHECK_LOG" | grep -v "Tasks:"
        if [ $TYPECHECK_EXIT -ne 0 ]; then
          echo ""
          echo "‚ùå TypeScript errors found!"
          echo ""
          echo "üí° Fix: Run 'pnpm typecheck' to see errors"
          echo ""
          exit 1
        fi

        if [ $TYPECHECK_DURATION -lt 3 ]; then
          echo "‚úÖ Type check passed (${TYPECHECK_DURATION}s - cached)"
        else
          echo "‚úÖ Type check passed (${TYPECHECK_DURATION}s)"
        fi

        # Display lint output
        cat "$LINT_LOG" | grep -v "Tasks:"
        if [ $LINT_EXIT -ne 0 ]; then
          echo ""
          echo "‚ùå Lint errors found!"
          echo ""
          echo "üí° Fix: Run 'pnpm lint' to see errors, or 'pnpm format' to auto-fix"
          echo ""
          exit 1
        fi

        echo "‚úÖ Lint check passed (${LINT_DURATION}s)"

        # Cleanup handled by trap

    # 4. Run CI script tests (fast: <2s)
    ci-scripts:
      run: |
        echo "üîß Running CI script tests..."
        if ! pnpm --silent test:ci-scripts; then
          echo ""
          echo "‚ùå CI script tests failed! Fix the scripts before pushing."
          echo ""
          echo "üí° To bypass this check (not recommended):"
          echo "   git push --no-verify"
          echo ""
          exit 1
        fi
        echo "‚úÖ CI scripts validated"

    # 5. Run unit tests (target: <20s for optimal DX)
    unit-tests:
      skip:
        - run: test "$SKIP_TESTS" = "1"
      run: |
        echo "üß™ Running unit tests..."
        START_TIME=$(date +%s)

        # Run tests directly (no artificial timeout - relies on Bash tool's natural limit)
        if ! pnpm --silent test:unit; then
          echo ""
          echo "‚ùå Unit tests failed! Fix the tests before pushing."
          echo ""
          echo "üí° To skip tests: SKIP_TESTS=1 git push"
          echo "üí° To bypass all hooks: git push --no-verify"
          echo ""
          exit 1
        fi

        END_TIME=$(date +%s)
        TEST_DURATION=$((END_TIME - START_TIME))

        # Provide feedback on execution time
        if [ $TEST_DURATION -lt 5 ]; then
          echo "‚úÖ All tests passed! (${TEST_DURATION}s - cached)"
        elif [ $TEST_DURATION -lt 15 ]; then
          echo "‚úÖ All tests passed! (${TEST_DURATION}s)"
        elif [ $TEST_DURATION -lt 30 ]; then
          echo "‚úÖ All tests passed! (${TEST_DURATION}s - acceptable)"
          if [ $TEST_DURATION -gt 15 ]; then
            echo "‚ö†Ô∏è  Tests took ${TEST_DURATION}s (target: 8-15s)"
            echo "üí° Run 'pnpm test:analyze-performance' to identify slow tests"
          fi
        else
          echo "‚ö†Ô∏è  Tests passed but took ${TEST_DURATION}s (target: <20s)"
          echo "üí° Run 'pnpm test:analyze-performance' to identify slow tests"
          echo "üí° Consider running fewer tests in pre-push or relying on CI for full suite"
        fi

        echo ""
        echo "üéâ All quality checks passed!"
        echo ""

# Skip hooks with SKIP_HOOKS=true or LEFTHOOK=0 environment variables

# Skip verbose meta and success messages for cleaner output
# Only show output from failed commands for better signal-to-noise ratio
skip_output:
  - meta
  - success

# Allow interactive terminal prompts (useful for debugging and development)
# Set to true to disable TTY if running in CI or non-interactive environments
no_tty: false
